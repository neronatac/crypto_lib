//! Definition of Salsa20, 12 and 8 algorithms (32 and 16-bytes key).

// https://cr.yp.to/snuffle/spec.pdf

use crate::symetric::stream_ciphers::common::StreamCipher;
use crate::utils::xor_arrays;

const SIG: [u32; 4] = [0x61707865, 0x3320646E, 0x79622D32, 0x6B206574];
const TAU: [u32; 4] = [0x61707865, 0x3120646E, 0x79622D36, 0x6B206574];

pub struct SalsaInitStruct {
    pub nonce: u64
}

type SalsaState = [u32; 16];

macro_rules! define_salsa {
    ( $salsa_name:ident, $nb_double_rounds:expr, $key_length:expr, $const_name:expr) => {
        pub struct $salsa_name {
            state: SalsaState,  // state is stored as little_endian words to simplify the hash function
            remaining_bytes: usize  // number of bytes that can be ciphered using the current state
        }

        impl $salsa_name {
            fn increment_counter(self: &mut Self) {
                // we don't do little-endian conversions here because the counter's bytes are already
                // swapped in the spec
                let mut counter = (self.state[9] as u64) << 32 | (self.state[8] as u64);
                counter = counter.wrapping_add(1);
                self.state[8] = counter as u32;
                self.state[9] = (counter >> 32) as u32;
            }
        }

        impl StreamCipher for $salsa_name {
            const KEY_SIZE: usize = $key_length;
            type InitStruct = SalsaInitStruct;
            type State = SalsaState;

            fn new(init_struct: &Self::InitStruct, key: &[u8; Self::KEY_SIZE]) -> Self{
                let n1 = ((init_struct.nonce >> 32) as u32).swap_bytes();
                let n0 = (init_struct.nonce as u32).swap_bytes();

                let k : [u32; 8] = (0..32)
                    .step_by(4)
                    .map(|i| u32::from_le_bytes(key[i%Self::KEY_SIZE..i%Self::KEY_SIZE+4].try_into().unwrap()))
                    .collect::<Vec<u32>>()
                    .try_into().unwrap();

                let state = [
                    $const_name[0], k[0], k[1], k[2],
                    k[3], $const_name[1], n1, n0,
                    0, 0, $const_name[2], k[4],
                    k[5], k[6], k[7], $const_name[3]
                ];

                $salsa_name{state, remaining_bytes: 0 }
            }

            fn cipher(&mut self, plaintext: &[u8], ciphertext: &mut [u8]) -> Result<(), &'static str> {
                // check parameters
                if plaintext.len() != ciphertext.len() {
                    return Err("Plaintext and ciphertext buffers must have the same length");
                }

                // do the thing
                let mut offset = 0;
                let max = plaintext.len();

                // process remaining bytes in state
                if self.remaining_bytes > 0 {
                    let hashed = hash_function(&self.state, $nb_double_rounds);
                    for j in 0..self.remaining_bytes {
                        ciphertext[j] = hashed[64 - self.remaining_bytes + j] ^ plaintext[j]
                    }
                    offset += self.remaining_bytes;

                    self.increment_counter();
                }

                while offset < max {
                    let hashed = hash_function(&self.state, $nb_double_rounds);

                    if max - offset >= 64 { // if an entire block can be ciphered
                        let res = xor_arrays(&hashed, &plaintext[offset..offset +64].try_into().unwrap());
                        for j in 0..64 {
                            ciphertext[offset +j] = res[j];
                        }
                        offset += 64;
                        self.increment_counter();
                    } else { // if only a partial block can be ciphered
                        for j in 0..max - offset {
                            ciphertext[offset +j] = hashed[j] ^ plaintext[offset +j];
                        }
                        self.remaining_bytes = 64 - (max - offset);
                        offset += max - offset;
                    }
                }

                Ok(())
            }
        }
    }
}

define_salsa!(Salsa20K32, 10, 32, SIG);
define_salsa!(Salsa20K16, 10, 16, TAU);
define_salsa!(Salsa12K32, 6, 32, SIG);
define_salsa!(Salsa12K16, 6, 16, TAU);
define_salsa!(Salsa8K32, 4, 32, SIG);
define_salsa!(Salsa8K16, 4, 16, TAU);

#[inline]
fn quarter_round(y0: u32, y1: u32, y2: u32, y3: u32) -> (u32, u32, u32, u32) {
    let z1 = y1 ^ ((y0.wrapping_add(y3)).rotate_left(7));
    let z2 = y2 ^ ((z1.wrapping_add(y0)).rotate_left(9));
    let z3 = y3 ^ ((z2.wrapping_add(z1)).rotate_left(13));
    let z0 = y0 ^ ((z3.wrapping_add(z2)).rotate_left(18));

    (z0, z1, z2, z3)
}

#[inline]
fn row_round(seq: &SalsaState) -> SalsaState {
    let mut ret = [0; 16];
    (ret[0], ret[1], ret[2], ret[3]) =
        quarter_round(seq[0], seq[1], seq[2], seq[3]);
    (ret[5], ret[6], ret[7], ret[4]) =
        quarter_round(seq[5], seq[6], seq[7], seq[4]);
    (ret[10], ret[11], ret[8], ret[9]) =
        quarter_round(seq[10], seq[11], seq[8], seq[9]);
    (ret[15], ret[12], ret[13], ret[14]) =
        quarter_round(seq[15], seq[12], seq[13], seq[14]);

    ret
}

#[inline]
fn column_round(seq: &SalsaState) -> SalsaState {
    let mut ret = [0; 16];
    (ret[0], ret[4], ret[8], ret[12]) =
        quarter_round(seq[0], seq[4], seq[8], seq[12]);
    (ret[5], ret[9], ret[13], ret[1]) =
        quarter_round(seq[5], seq[9], seq[13], seq[1]);
    (ret[10], ret[14], ret[2], ret[6]) =
        quarter_round(seq[10], seq[14], seq[2], seq[6]);
    (ret[15], ret[3], ret[7], ret[11]) =
        quarter_round(seq[15], seq[3], seq[7], seq[11]);

    ret
}

#[inline]
fn double_round(seq: &SalsaState) -> SalsaState {
    row_round(&column_round(seq))
}

fn hash_function(state: &SalsaState, nb_double_rounds: usize) -> [u8; 64] {
    let mut tmp = *state;

    for _ in 0..nb_double_rounds {
        tmp = double_round(&tmp);
    }

    for i in 0..16 {
        tmp[i] = tmp[i].wrapping_add(state[i]);
    }

    state_to_bytes_and_swap(&tmp)
}

fn state_to_bytes_and_swap(state: &SalsaState) -> [u8; 64] {
    state
        .iter()
        .map(|i| i.to_le_bytes())
        .flatten()
        .collect::<Vec<u8>>()
        .try_into().unwrap()
}


#[cfg(test)]
mod tests_chacha {
    use super::*;

    #[test]
    fn test_quarter_round() {
        let y0 = 0xd3917c5b;
        let y1 = 0x55f1c407;
        let y2 = 0x52a58a7a;
        let y3 = 0x8f887a3b;

        let res = quarter_round(y0, y1, y2, y3);
        assert_eq!(res, (0x3e2f308c, 0xd90a8f36, 0x6ab2a923, 0x2883524c));
    }

    #[test]
    fn test_rowround() {
        let state = [
            0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,
            0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,
            0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,
            0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a
        ];

        let expected = [
            0xa890d39d, 0x65d71596, 0xe9487daa, 0xc8ca6a86,
            0x949d2192, 0x764b7754, 0xe408d9b9, 0x7a41b4d1,
            0x3402e183, 0x3c3af432, 0x50669f96, 0xd89ef0a8,
            0x0040ede5, 0xb545fbce, 0xd257ed4f, 0x1818882d
        ];

        let res = row_round(&state);
        assert_eq!(res, expected);
    }

    #[test]
    fn test_columnround() {
        let state = [
            0x08521bd6, 0x1fe88837, 0xbb2aa576, 0x3aa26365,
            0xc54c6a5b, 0x2fc74c2f, 0x6dd39cc3, 0xda0a64f6,
            0x90a2f23d, 0x067f95a6, 0x06b35f61, 0x41e4732e,
            0xe859c100, 0xea4d84b7, 0x0f619bff, 0xbc6e965a
        ];

        let expected = [
            0x8c9d190a, 0xce8e4c90, 0x1ef8e9d3, 0x1326a71a,
            0x90a20123, 0xead3c4f3, 0x63a091a0, 0xf0708d69,
            0x789b010c, 0xd195a681, 0xeb7d5504, 0xa774135c,
            0x481c2027, 0x53a8e4b5, 0x4c1f89c5, 0x3f78c9c8
        ];

        let res = column_round(&state);
        assert_eq!(res, expected);
    }

    #[test]
    fn test_doubleround() {
        let state = [
            0xde501066, 0x6f9eb8f7, 0xe4fbbd9b, 0x454e3f57,
            0xb75540d3, 0x43e93a4c, 0x3a6f2aa0, 0x726d6b36,
            0x9243f484, 0x9145d1e8, 0x4fa9d247, 0xdc8dee11,
            0x054bf545, 0x254dd653, 0xd9421b6d, 0x67b276c1
        ];

        let expected = [
            0xccaaf672, 0x23d960f7, 0x9153e63a, 0xcd9a60d0,
            0x50440492, 0xf07cad19, 0xae344aa0, 0xdf4cfdfc,
            0xca531c29, 0x8e7943db, 0xac1680cd, 0xd503ca00,
            0xa74b2ad6, 0xbc331c5c, 0x1dda24c7, 0xee928277
        ];

        let res = double_round(&state);
        assert_eq!(res, expected);
    }

    #[test]
    fn test_hash_function() {
        let bytes = [88,118,104, 54, 79,201,235, 79, 3, 81,156, 47,203, 26,244,243,
            191,187,234,136,211,159, 13,115, 76, 55, 82,183, 3,117,222, 37,
            86, 16,179,207, 49,237,179, 48, 1,106,178,219,175,199,166, 48,
            238, 55,204, 36, 31,240, 32, 63, 15, 83, 93,161,116,147, 48,113];
        let mut state = (0..64)
            .step_by(4)
            .map(|i| u32::from_le_bytes(bytes[i..i+4].try_into().unwrap()))
            .collect::<Vec<u32>>()
            .try_into().unwrap();

        let expected_bytes = [179, 19, 48,202,219,236,232,135,111,155,110, 18, 24,232, 95,158,
            26,110,170,154,109, 42,178,168,156,240,248,238,168,196,190,203,
            69,144, 51, 57, 29, 29,150, 26,150, 30,235,249,190,163,251, 48,
            27,111,114,114,118, 40,152,157,180, 57, 27, 94,107, 42,236, 35];

        let res = hash_function(&mut state, 10);

        assert_eq!(res, expected_bytes);
    }

    #[test]
    fn test_cipher_1_block_k32() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
        ];
        let plaintext = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext = [0; 64];


        let expected = [
            0x12, 0xde, 0x44, 0x05, 0x3e, 0x67, 0xf5, 0x12,
            0x8b, 0xa5, 0x10, 0x4e, 0x10, 0x3a, 0x4d, 0xf5,
            0xb0, 0x1b, 0xc8, 0xd2, 0x3f, 0x6e, 0xab, 0x61,
            0x2a, 0x0a, 0x7d, 0xa6, 0x4a, 0xc4, 0x1e, 0xaf,
            0x4d, 0x58, 0xb2, 0xed, 0xb0, 0xdb, 0xd0, 0xe9,
            0x48, 0xc3, 0x61, 0x80, 0xc4, 0x55, 0x20, 0xc2,
            0xba, 0x49, 0x2a, 0x4c, 0x4c, 0xde, 0x06, 0xe4,
            0x7a, 0xaa, 0xea, 0x43, 0xb0, 0x6d, 0xb6, 0x8b,
        ];
        
        let mut salsa = Salsa20K32::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext, &mut ciphertext).expect("Error during Salsa20K32 test!");
        assert_eq!(ciphertext, expected);
    }

    #[test]
    fn test_cipher_2_blocks_k32() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
        ];
        let plaintext = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,

            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext = [0; 128];


        let expected = [
            0x12, 0xde, 0x44, 0x05, 0x3e, 0x67, 0xf5, 0x12,
            0x8b, 0xa5, 0x10, 0x4e, 0x10, 0x3a, 0x4d, 0xf5,
            0xb0, 0x1b, 0xc8, 0xd2, 0x3f, 0x6e, 0xab, 0x61,
            0x2a, 0x0a, 0x7d, 0xa6, 0x4a, 0xc4, 0x1e, 0xaf,
            0x4d, 0x58, 0xb2, 0xed, 0xb0, 0xdb, 0xd0, 0xe9,
            0x48, 0xc3, 0x61, 0x80, 0xc4, 0x55, 0x20, 0xc2,
            0xba, 0x49, 0x2a, 0x4c, 0x4c, 0xde, 0x06, 0xe4,
            0x7a, 0xaa, 0xea, 0x43, 0xb0, 0x6d, 0xb6, 0x8b,

            0x60, 0x80, 0x08, 0xde, 0x04, 0x22, 0xf9, 0x07,
            0x07, 0x2d, 0x5c, 0x70, 0x0c, 0x89, 0x51, 0xef,
            0xec, 0xcb, 0xe3, 0xb6, 0x5a, 0x45, 0xa8, 0xff,
            0x9a, 0xb5, 0x1c, 0xcd, 0xa7, 0xf2, 0xa6, 0x7f,
            0x38, 0xf4, 0x49, 0x74, 0x89, 0xe7, 0x12, 0x62,
            0x77, 0xf3, 0x48, 0xc6, 0xbb, 0xdd, 0xd4, 0x92,
            0xa8, 0x69, 0xd6, 0xac, 0x9d, 0xdb, 0x2f, 0x80,
            0x6a, 0x5d, 0x8e, 0xfb, 0xdf, 0x10, 0xb9, 0x86,
        ];

        let mut salsa = Salsa20K32::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext, &mut ciphertext).expect("Error during Salsa20K32 test!");
        assert_eq!(ciphertext, expected);
    }

    #[test]
    fn test_cipher_3_blocks_k32() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
        ];
        let plaintext = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,

            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,

            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext = [0; 192];


        let expected = [
            0x12, 0xde, 0x44, 0x05, 0x3e, 0x67, 0xf5, 0x12,
            0x8b, 0xa5, 0x10, 0x4e, 0x10, 0x3a, 0x4d, 0xf5,
            0xb0, 0x1b, 0xc8, 0xd2, 0x3f, 0x6e, 0xab, 0x61,
            0x2a, 0x0a, 0x7d, 0xa6, 0x4a, 0xc4, 0x1e, 0xaf,
            0x4d, 0x58, 0xb2, 0xed, 0xb0, 0xdb, 0xd0, 0xe9,
            0x48, 0xc3, 0x61, 0x80, 0xc4, 0x55, 0x20, 0xc2,
            0xba, 0x49, 0x2a, 0x4c, 0x4c, 0xde, 0x06, 0xe4,
            0x7a, 0xaa, 0xea, 0x43, 0xb0, 0x6d, 0xb6, 0x8b,

            0x60, 0x80, 0x08, 0xde, 0x04, 0x22, 0xf9, 0x07,
            0x07, 0x2d, 0x5c, 0x70, 0x0c, 0x89, 0x51, 0xef,
            0xec, 0xcb, 0xe3, 0xb6, 0x5a, 0x45, 0xa8, 0xff,
            0x9a, 0xb5, 0x1c, 0xcd, 0xa7, 0xf2, 0xa6, 0x7f,
            0x38, 0xf4, 0x49, 0x74, 0x89, 0xe7, 0x12, 0x62,
            0x77, 0xf3, 0x48, 0xc6, 0xbb, 0xdd, 0xd4, 0x92,
            0xa8, 0x69, 0xd6, 0xac, 0x9d, 0xdb, 0x2f, 0x80,
            0x6a, 0x5d, 0x8e, 0xfb, 0xdf, 0x10, 0xb9, 0x86,

            0xa9, 0xa3, 0x00, 0x73, 0x68, 0x21, 0x16, 0xc3,
            0x98, 0x3d, 0x79, 0x6e, 0x0b, 0xfc, 0xf5, 0x6c,
            0xc4, 0x82, 0x4d, 0xbb, 0x06, 0xc4, 0x72, 0x56,
            0x36, 0x0f, 0x08, 0xdf, 0x45, 0x2c, 0xf7, 0x30,
            0x19, 0x82, 0xcf, 0xf2, 0x26, 0xcd, 0x1f, 0x15,
            0x51, 0x4f, 0x7f, 0xe5, 0x2c, 0x4b, 0xb3, 0x60,
            0xb3, 0xc8, 0x0f, 0xe8, 0x24, 0x88, 0xe3, 0xed,
            0x5b, 0xb1, 0x56, 0x38, 0x35, 0x1f, 0x21, 0x8f,
        ];

        let mut salsa = Salsa20K32::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext, &mut ciphertext).expect("Error during Salsa20K32 test!");
        assert_eq!(ciphertext, expected);
    }

    #[test]
    fn test_cipher_3_times_1_block_k32() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
        ];
        let plaintext1 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

        let plaintext2 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

        let plaintext3 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext1 = [0; 64];
        let mut ciphertext2 = [0; 64];
        let mut ciphertext3 = [0; 64];

        let expected1 = [
            0x12, 0xde, 0x44, 0x05, 0x3e, 0x67, 0xf5, 0x12,
            0x8b, 0xa5, 0x10, 0x4e, 0x10, 0x3a, 0x4d, 0xf5,
            0xb0, 0x1b, 0xc8, 0xd2, 0x3f, 0x6e, 0xab, 0x61,
            0x2a, 0x0a, 0x7d, 0xa6, 0x4a, 0xc4, 0x1e, 0xaf,
            0x4d, 0x58, 0xb2, 0xed, 0xb0, 0xdb, 0xd0, 0xe9,
            0x48, 0xc3, 0x61, 0x80, 0xc4, 0x55, 0x20, 0xc2,
            0xba, 0x49, 0x2a, 0x4c, 0x4c, 0xde, 0x06, 0xe4,
            0x7a, 0xaa, 0xea, 0x43, 0xb0, 0x6d, 0xb6, 0x8b];

        let expected2 = [
            0x60, 0x80, 0x08, 0xde, 0x04, 0x22, 0xf9, 0x07,
            0x07, 0x2d, 0x5c, 0x70, 0x0c, 0x89, 0x51, 0xef,
            0xec, 0xcb, 0xe3, 0xb6, 0x5a, 0x45, 0xa8, 0xff,
            0x9a, 0xb5, 0x1c, 0xcd, 0xa7, 0xf2, 0xa6, 0x7f,
            0x38, 0xf4, 0x49, 0x74, 0x89, 0xe7, 0x12, 0x62,
            0x77, 0xf3, 0x48, 0xc6, 0xbb, 0xdd, 0xd4, 0x92,
            0xa8, 0x69, 0xd6, 0xac, 0x9d, 0xdb, 0x2f, 0x80,
            0x6a, 0x5d, 0x8e, 0xfb, 0xdf, 0x10, 0xb9, 0x86];

        let expected3 = [
            0xa9, 0xa3, 0x00, 0x73, 0x68, 0x21, 0x16, 0xc3,
            0x98, 0x3d, 0x79, 0x6e, 0x0b, 0xfc, 0xf5, 0x6c,
            0xc4, 0x82, 0x4d, 0xbb, 0x06, 0xc4, 0x72, 0x56,
            0x36, 0x0f, 0x08, 0xdf, 0x45, 0x2c, 0xf7, 0x30,
            0x19, 0x82, 0xcf, 0xf2, 0x26, 0xcd, 0x1f, 0x15,
            0x51, 0x4f, 0x7f, 0xe5, 0x2c, 0x4b, 0xb3, 0x60,
            0xb3, 0xc8, 0x0f, 0xe8, 0x24, 0x88, 0xe3, 0xed,
            0x5b, 0xb1, 0x56, 0x38, 0x35, 0x1f, 0x21, 0x8f,
        ];

        let mut salsa = Salsa20K32::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext1, &mut ciphertext1).expect("Error during Salsa20K32 test!");
        salsa.cipher(&plaintext2, &mut ciphertext2).expect("Error during Salsa20K32 test!");
        salsa.cipher(&plaintext3, &mut ciphertext3).expect("Error during Salsa20K32 test!");
        assert_eq!(ciphertext1, expected1);
        assert_eq!(ciphertext2, expected2);
        assert_eq!(ciphertext3, expected3);
    }

    #[test]
    fn test_cipher_2_blocks_fragmented_k32() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
        ];
        let plaintext1 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

        let plaintext2 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext1 = [0; 72];
        let mut ciphertext2 = [0; 56];


        let expected1 = [
            0x12, 0xde, 0x44, 0x05, 0x3e, 0x67, 0xf5, 0x12,
            0x8b, 0xa5, 0x10, 0x4e, 0x10, 0x3a, 0x4d, 0xf5,
            0xb0, 0x1b, 0xc8, 0xd2, 0x3f, 0x6e, 0xab, 0x61,
            0x2a, 0x0a, 0x7d, 0xa6, 0x4a, 0xc4, 0x1e, 0xaf,
            0x4d, 0x58, 0xb2, 0xed, 0xb0, 0xdb, 0xd0, 0xe9,
            0x48, 0xc3, 0x61, 0x80, 0xc4, 0x55, 0x20, 0xc2,
            0xba, 0x49, 0x2a, 0x4c, 0x4c, 0xde, 0x06, 0xe4,
            0x7a, 0xaa, 0xea, 0x43, 0xb0, 0x6d, 0xb6, 0x8b,
            0x60, 0x80, 0x08, 0xde, 0x04, 0x22, 0xf9, 0x07];

        let expected2 = [
            0x07, 0x2d, 0x5c, 0x70, 0x0c, 0x89, 0x51, 0xef,
            0xec, 0xcb, 0xe3, 0xb6, 0x5a, 0x45, 0xa8, 0xff,
            0x9a, 0xb5, 0x1c, 0xcd, 0xa7, 0xf2, 0xa6, 0x7f,
            0x38, 0xf4, 0x49, 0x74, 0x89, 0xe7, 0x12, 0x62,
            0x77, 0xf3, 0x48, 0xc6, 0xbb, 0xdd, 0xd4, 0x92,
            0xa8, 0x69, 0xd6, 0xac, 0x9d, 0xdb, 0x2f, 0x80,
            0x6a, 0x5d, 0x8e, 0xfb, 0xdf, 0x10, 0xb9, 0x86,
        ];

        let mut salsa = Salsa20K32::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext1, &mut ciphertext1).expect("Error during Salsa20K32 test!");
        salsa.cipher(&plaintext2, &mut ciphertext2).expect("Error during Salsa20K32 test!");
        assert_eq!(ciphertext1, expected1);
        assert_eq!(ciphertext2, expected2);
    }

    #[test]
    fn test_cipher_1_block_k16() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        ];
        let plaintext = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext = [0; 64];


        let expected = [
            0x92, 0xed, 0x82, 0xfa, 0x0d, 0x5f, 0x51, 0x34,
            0x3a, 0xb0, 0xcc, 0xe9, 0xa6, 0xe6, 0xef, 0x81,
            0x54, 0x23, 0x9e, 0x58, 0x8b, 0x8c, 0xb2, 0xa0,
            0xac, 0xc5, 0xc1, 0xe4, 0x3d, 0x6d, 0x14, 0xd0,
            0x29, 0xef, 0xa5, 0x17, 0x17, 0x59, 0xc1, 0x09,
            0xdb, 0x40, 0xae, 0x43, 0x0d, 0xaf, 0x24, 0x80,
            0xe6, 0xd2, 0x93, 0x09, 0xc9, 0x0c, 0x59, 0x11,
            0x3f, 0x85, 0x17, 0x6e, 0x01, 0x47, 0x7e, 0x40,
        ];

        let mut salsa = Salsa20K16::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext, &mut ciphertext).expect("Error during Salsa20K16 test!");
        assert_eq!(ciphertext, expected);
    }

    #[test]
    fn test_cipher_2_blocks_k16() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        ];
        let plaintext = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,

            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext = [0; 128];


        let expected = [
            0x92, 0xed, 0x82, 0xfa, 0x0d, 0x5f, 0x51, 0x34,
            0x3a, 0xb0, 0xcc, 0xe9, 0xa6, 0xe6, 0xef, 0x81,
            0x54, 0x23, 0x9e, 0x58, 0x8b, 0x8c, 0xb2, 0xa0,
            0xac, 0xc5, 0xc1, 0xe4, 0x3d, 0x6d, 0x14, 0xd0,
            0x29, 0xef, 0xa5, 0x17, 0x17, 0x59, 0xc1, 0x09,
            0xdb, 0x40, 0xae, 0x43, 0x0d, 0xaf, 0x24, 0x80,
            0xe6, 0xd2, 0x93, 0x09, 0xc9, 0x0c, 0x59, 0x11,
            0x3f, 0x85, 0x17, 0x6e, 0x01, 0x47, 0x7e, 0x40,

            0xf3, 0x26, 0xe7, 0x95, 0x9d, 0x7e, 0x5f, 0x25,
            0x3b, 0xe2, 0xcc, 0x5a, 0x87, 0xbc, 0xa8, 0xd8,
            0x67, 0xcd, 0x59, 0x7f, 0x2c, 0x38, 0x06, 0x4e,
            0x86, 0x44, 0x98, 0xfc, 0xaf, 0xa1, 0xaf, 0x5a,
            0x94, 0x13, 0x5f, 0xb2, 0xb3, 0xc1, 0x01, 0x51,
            0x00, 0xb1, 0x9f, 0x49, 0xbb, 0xea, 0xc1, 0xae,
            0xc4, 0xc3, 0x4a, 0x62, 0x7e, 0x3b, 0x50, 0x4f,
            0x60, 0x5f, 0xb8, 0xb3, 0x5e, 0x06, 0xff, 0x69,
        ];

        let mut salsa = Salsa20K16::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext, &mut ciphertext).expect("Error during Salsa20K16 test!");
        assert_eq!(ciphertext, expected);
    }

    #[test]
    fn test_cipher_3_blocks_k16() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        ];
        let plaintext = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,

            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,

            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext = [0; 192];


        let expected = [
            0x92, 0xed, 0x82, 0xfa, 0x0d, 0x5f, 0x51, 0x34,
            0x3a, 0xb0, 0xcc, 0xe9, 0xa6, 0xe6, 0xef, 0x81,
            0x54, 0x23, 0x9e, 0x58, 0x8b, 0x8c, 0xb2, 0xa0,
            0xac, 0xc5, 0xc1, 0xe4, 0x3d, 0x6d, 0x14, 0xd0,
            0x29, 0xef, 0xa5, 0x17, 0x17, 0x59, 0xc1, 0x09,
            0xdb, 0x40, 0xae, 0x43, 0x0d, 0xaf, 0x24, 0x80,
            0xe6, 0xd2, 0x93, 0x09, 0xc9, 0x0c, 0x59, 0x11,
            0x3f, 0x85, 0x17, 0x6e, 0x01, 0x47, 0x7e, 0x40,

            0xf3, 0x26, 0xe7, 0x95, 0x9d, 0x7e, 0x5f, 0x25,
            0x3b, 0xe2, 0xcc, 0x5a, 0x87, 0xbc, 0xa8, 0xd8,
            0x67, 0xcd, 0x59, 0x7f, 0x2c, 0x38, 0x06, 0x4e,
            0x86, 0x44, 0x98, 0xfc, 0xaf, 0xa1, 0xaf, 0x5a,
            0x94, 0x13, 0x5f, 0xb2, 0xb3, 0xc1, 0x01, 0x51,
            0x00, 0xb1, 0x9f, 0x49, 0xbb, 0xea, 0xc1, 0xae,
            0xc4, 0xc3, 0x4a, 0x62, 0x7e, 0x3b, 0x50, 0x4f,
            0x60, 0x5f, 0xb8, 0xb3, 0x5e, 0x06, 0xff, 0x69,

            0x3a, 0xc2, 0x60, 0x12, 0x95, 0x74, 0xda, 0x4b,
            0xe1, 0xe0, 0xc6, 0xdd, 0x34, 0x3e, 0x02, 0xde,
            0x65, 0x31, 0xd4, 0x27, 0xa5, 0x1c, 0x66, 0xcd,
            0x92, 0x63, 0xe3, 0xec, 0xd3, 0x70, 0xb6, 0x30,
            0x7d, 0x1a, 0x83, 0xe1, 0x7a, 0xec, 0x6f, 0xe2,
            0x0f, 0xf3, 0xbe, 0xa2, 0xb7, 0x36, 0xcb, 0xbf,
            0x86, 0xd6, 0x3b, 0x1a, 0x05, 0x4b, 0x41, 0x00,
            0x54, 0x5e, 0x59, 0x59, 0x2c, 0x2f, 0xe9, 0xa3,
        ];

        let mut salsa = Salsa20K16::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext, &mut ciphertext).expect("Error during Salsa20K16 test!");
        assert_eq!(ciphertext, expected);
    }

    #[test]
    fn test_cipher_3_times_1_block_k16() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        ];
        let plaintext1 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

        let plaintext2 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

        let plaintext3 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext1 = [0; 64];
        let mut ciphertext2 = [0; 64];
        let mut ciphertext3 = [0; 64];

        let expected1 = [
            0x92, 0xed, 0x82, 0xfa, 0x0d, 0x5f, 0x51, 0x34,
            0x3a, 0xb0, 0xcc, 0xe9, 0xa6, 0xe6, 0xef, 0x81,
            0x54, 0x23, 0x9e, 0x58, 0x8b, 0x8c, 0xb2, 0xa0,
            0xac, 0xc5, 0xc1, 0xe4, 0x3d, 0x6d, 0x14, 0xd0,
            0x29, 0xef, 0xa5, 0x17, 0x17, 0x59, 0xc1, 0x09,
            0xdb, 0x40, 0xae, 0x43, 0x0d, 0xaf, 0x24, 0x80,
            0xe6, 0xd2, 0x93, 0x09, 0xc9, 0x0c, 0x59, 0x11,
            0x3f, 0x85, 0x17, 0x6e, 0x01, 0x47, 0x7e, 0x40];

        let expected2 = [
            0xf3, 0x26, 0xe7, 0x95, 0x9d, 0x7e, 0x5f, 0x25,
            0x3b, 0xe2, 0xcc, 0x5a, 0x87, 0xbc, 0xa8, 0xd8,
            0x67, 0xcd, 0x59, 0x7f, 0x2c, 0x38, 0x06, 0x4e,
            0x86, 0x44, 0x98, 0xfc, 0xaf, 0xa1, 0xaf, 0x5a,
            0x94, 0x13, 0x5f, 0xb2, 0xb3, 0xc1, 0x01, 0x51,
            0x00, 0xb1, 0x9f, 0x49, 0xbb, 0xea, 0xc1, 0xae,
            0xc4, 0xc3, 0x4a, 0x62, 0x7e, 0x3b, 0x50, 0x4f,
            0x60, 0x5f, 0xb8, 0xb3, 0x5e, 0x06, 0xff, 0x69];

        let expected3 = [
            0x3a, 0xc2, 0x60, 0x12, 0x95, 0x74, 0xda, 0x4b,
            0xe1, 0xe0, 0xc6, 0xdd, 0x34, 0x3e, 0x02, 0xde,
            0x65, 0x31, 0xd4, 0x27, 0xa5, 0x1c, 0x66, 0xcd,
            0x92, 0x63, 0xe3, 0xec, 0xd3, 0x70, 0xb6, 0x30,
            0x7d, 0x1a, 0x83, 0xe1, 0x7a, 0xec, 0x6f, 0xe2,
            0x0f, 0xf3, 0xbe, 0xa2, 0xb7, 0x36, 0xcb, 0xbf,
            0x86, 0xd6, 0x3b, 0x1a, 0x05, 0x4b, 0x41, 0x00,
            0x54, 0x5e, 0x59, 0x59, 0x2c, 0x2f, 0xe9, 0xa3];

        let mut salsa = Salsa20K16::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext1, &mut ciphertext1).expect("Error during Salsa20K16 test!");
        salsa.cipher(&plaintext2, &mut ciphertext2).expect("Error during Salsa20K16 test!");
        salsa.cipher(&plaintext3, &mut ciphertext3).expect("Error during Salsa20K16 test!");
        assert_eq!(ciphertext1, expected1);
        assert_eq!(ciphertext2, expected2);
        assert_eq!(ciphertext3, expected3);
    }

    #[test]
    fn test_cipher_2_blocks_fragmented_k16() {
        let nonce = 0x0011223344556677;
        let key = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        ];
        let plaintext1 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

        let plaintext2 = [
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        ];
        let mut ciphertext1 = [0; 72];
        let mut ciphertext2 = [0; 56];


        let expected1 = [
            0x92, 0xed, 0x82, 0xfa, 0x0d, 0x5f, 0x51, 0x34,
            0x3a, 0xb0, 0xcc, 0xe9, 0xa6, 0xe6, 0xef, 0x81,
            0x54, 0x23, 0x9e, 0x58, 0x8b, 0x8c, 0xb2, 0xa0,
            0xac, 0xc5, 0xc1, 0xe4, 0x3d, 0x6d, 0x14, 0xd0,
            0x29, 0xef, 0xa5, 0x17, 0x17, 0x59, 0xc1, 0x09,
            0xdb, 0x40, 0xae, 0x43, 0x0d, 0xaf, 0x24, 0x80,
            0xe6, 0xd2, 0x93, 0x09, 0xc9, 0x0c, 0x59, 0x11,
            0x3f, 0x85, 0x17, 0x6e, 0x01, 0x47, 0x7e, 0x40,

            0xf3, 0x26, 0xe7, 0x95, 0x9d, 0x7e, 0x5f, 0x25];

        let expected2 = [
            0x3b, 0xe2, 0xcc, 0x5a, 0x87, 0xbc, 0xa8, 0xd8,
            0x67, 0xcd, 0x59, 0x7f, 0x2c, 0x38, 0x06, 0x4e,
            0x86, 0x44, 0x98, 0xfc, 0xaf, 0xa1, 0xaf, 0x5a,
            0x94, 0x13, 0x5f, 0xb2, 0xb3, 0xc1, 0x01, 0x51,
            0x00, 0xb1, 0x9f, 0x49, 0xbb, 0xea, 0xc1, 0xae,
            0xc4, 0xc3, 0x4a, 0x62, 0x7e, 0x3b, 0x50, 0x4f,
            0x60, 0x5f, 0xb8, 0xb3, 0x5e, 0x06, 0xff, 0x69];

        let mut salsa = Salsa20K16::new(&SalsaInitStruct{ nonce }, &key);
        salsa.cipher(&plaintext1, &mut ciphertext1).expect("Error during Salsa20K16 test!");
        salsa.cipher(&plaintext2, &mut ciphertext2).expect("Error during Salsa20K16 test!");
        assert_eq!(ciphertext1, expected1);
        assert_eq!(ciphertext2, expected2);
    }
}